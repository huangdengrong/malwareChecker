import os
import sys
import shutil
import ast
from sklearn import svm
import numpy as np
from sklearn.model_selection import RepeatedStratifiedKFold, cross_validate
from sklearn import preprocessing
from scipy.stats import sem

good_dir = None
bad_dir = None
walk_dir = None
riskyAPIs = []
riskyPerm = []
malwapk = []
goodapk = []
totalapk = []
X = [[]]
y = []
needToTrain = True
firstRun = True


def importRiskyAPI():
    global riskyAPIs
    f = open("riskyAPI.txt", 'r')
    lines = f.readlines()
    for line in lines:
        line = line.replace('.', '/')
        riskyAPIs.append(line[:-1])
    f.close()

def importRiskyPerms():
    global riskyPerm
    f = open("riskyPerm.txt", 'r')
    lines = f.readlines()
    for line in lines:
        riskyPerm.append(line[:-1])
    f.close()

def decompile():
    global malwapk
    global goodapk
    global totalapk
    global y
    malwapk = []
    goodapk = []
    totalapk = []
    y = []
    #apktool = "/usr/local/bin/apktool.jar"
    i = 0
    for root, subdirs, files in os.walk(walk_dir):
        list_file_path = os.path.join(root, 'temp.txt')
        print(list_file_path)
        try:
            with open(list_file_path, 'wb') as list_file:
                for file in files:
                    if file.endswith(".apk"):
                        i = i+1
                        if("buoni" in list_file_path):
                            goodapk.append(file)
                            y.append(0)
                        else:
                            malwapk.append(file)
                            y.append(1)
                        totalapk.append(file)
                        print(str(i) + "-" + file)
                        os.system("apktool" + " d " + root + "/" + file + " -o " + root + "/" + file[:-4])
        except:
            print("Error " + file + " not found")
    print("Dataset of malicious apks: " + str(malwapk))
    print("Dataset of good apks: " + str(goodapk))
    print("Resulting y: " + str(y))  
    mainMenu()
    return    

def decompileFolder(path):
    apks = os.listdir(path)
    for apk in apks:
        if not apk.startswith("."):
            try:
                apkPth = os.path.join(path, apk)
                os.system("apktool" + " d " + apkPth + " -o " + path + "/" + apk[:-4])
            except:
                print("File " + apkPth + " not found")
    return                  

def analyseApk():
    if needToTrain is False:
        pathsAk = []
        findPerm = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
        print("Enter the absolute path where apk to analyse are stored:")
        apkdir = input()
        print("Decompiling apk in " + apkdir + " ...")
        decompileFolder(apkdir)
        apks = [d for d in os.listdir(apkdir) if os.path.isdir(os.path.join(apkdir, d))]
        print(apks)
        logfile = open('results.log', 'w+')
        for a in apks:
            pathApk = os.path.join(apkdir, a)
            pathsAk.append(pathApk)
            checkPermissions(pathApk, findPerm)
            checkAPI(pathApk, findPerm)
            print(findPerm)
            ans = clf.predict([findPerm])
            if '[0]' in str(ans):
                logfile.write(a + ' is clean'  + '\n')
                print(a + ' is clean'  + '\n')
            elif '[1]' in str(ans):
                logfile.write(a + ' is malicious'  + '\n')
                print(a + ' is malicious'  + '\n')
            
            findPerm = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

        logfile.close()
        print("Would you like to remove all compiled folders? y/n")
        choice = input()  
        if str(choice) is 'y':
            for ak in pathsAk:
                shutil.rmtree(ak)
        mainMenu()
    else:
        print("You need to train the classifier first!")
        mainMenu()
    return

def trainClass():
    if(needToTrain is False):
        global clf
        global X
        global bad_dir
        global good_dir
        X = []
        malwPerm = []
        apkPath = []
        findPerm = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
        good_dirs = [d for d in os.listdir(good_dir) if os.path.isdir(os.path.join(good_dir, d))]
        bad_dirs = [d for d in os.listdir(bad_dir) if os.path.isdir(os.path.join(bad_dir, d))]
        
        for apk in good_dirs:
            pathApk = os.path.join(good_dir, apk)
            apkPath.append(pathApk)

            checkPermissions(pathApk, findPerm)
            checkAPI(pathApk, findPerm)
            print(findPerm)
            X.append(findPerm)
            findPerm = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            

        for apk in bad_dirs:
            pathApk = os.path.join(bad_dir, apk)
            apkPath.append(pathApk)

            checkPermissions(pathApk, findPerm)
            checkAPI(pathApk, findPerm)
            print(findPerm)
            X.append(findPerm)
            findPerm = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
        print("\n\nResulting X classifier array = " + str(X))
        print("Resulting y classifier array = " + str(y))
        with open('classifier.txt', 'w+')as openfile:
            openfile.write('apk=' + str(totalapk))
            openfile.write('\n')
            openfile.write("X=" + str(X)) 
            openfile.write('\n')
            openfile.write("y=" + str(y))
        openfile.close()
        clf = svm.SVC()
        clf.fit(X, y)
        needToTrain = False
        mainMenu()
    else:
        print("You need to decompile first!")
        mainMenu()
    return

def checkPermissions(pathApk, array):
    print(pathApk)
    try:
        with open(pathApk + '/AndroidManifest.xml', 'r', encoding='windows-1252') as openfile:
                lines = openfile.readlines()
                for line in lines:
                    if 'uses-permission' in line:
                        for perm in riskyPerm:
                            if perm in line:
                                if "RECEIVE_BOOT_COMPLETED" in perm:
                                    array[0] = 1
                                elif 'READ_PHONE_STATE' in perm:
                                    array[1] = 1
                                elif 'GET_ACCOUNTS' in perm:
                                    array[2] = 1
                                elif 'READ_SMS' in perm:
                                    array[3] = 1
                                elif 'CALL_PHONE' in perm:
                                    array[4] = 1
                                elif 'WRITE_EXTERNAL_STORAGE' in perm:
                                    array[5] = 1
                                elif 'READ_EXTERNAL_STORAGE' in perm:
                                    array[6] = 1
        openfile.close()
    except:
        print("Problem with manifest file in " + str(pathApk))

def checkAPI(pathApk, array):
    malwAPI = []
    
    for path, subdirs, files in os.walk(pathApk):
        for file in files:
            if "smali" in path:
                try:
                    with open(os.path.join(path, file), 'r', encoding='windows-1252') as openfile:
                        lines = openfile.readlines()
                        for line in lines:
                            for api in riskyAPIs:
                                if api in line and api not in malwAPI:
                                    malwAPI.append(api)               
                    openfile.close()
                except:
                    print("Problem analysing " + str(openfile))
    for api in malwAPI:
        if "Cipher" in api:
            array[7] = 1
        elif "WifiManager" in api:
            array[8] = 1
        elif "TelephonyManager" in api:
            array[9] = 1
        elif "KeyboardView" in api:
            array[10] = 1
        elif "Camera" in api:
            array[11] = 1
        elif "AccountManager" in api:
            array[12] = 1
        elif "ServerSocket" in api:
            array[13] = 1
        elif "AccessControlContext" in api:
            array[14] = 1
        elif "DefaultHttpClient" in api:
            array[15] = 1
        elif "SpeechRecognizer" in api:
            array[16] = 1
        
def validate():
    global clf
    global X, y

    sco = ['accuracy', 'precision', 'recall', 'f1']

    skf = RepeatedStratifiedKFold(n_splits=2, n_repeats=10)

    results = cross_validate(estimator=clf, X=X, y=y, cv=skf, scoring=sco)

    print("--------------------------------------")
    print("Accuracy: %0.2f (+/- %0.2f)" % (results['test_accuracy'].mean(), sem(results['test_accuracy'])))
    print("Precision: %0.2f (+/- %0.2f)" % (results['test_precision'].mean(), sem(results['test_precision'])))
    print("Recall: %0.2f (+/- %0.2f)" % (results['test_recall'].mean(), sem(results['test_recall'])))
    print("F-Score: %0.2f (+/- %0.2f)" % (results['test_f1'].mean(), sem(results['test_f1'])))
    
    mainMenu()
    return


def checkWorkingDir(mode: str):
    global walk_dir
    if(mode == 'init'):
        if len(sys.argv) == 1:
            print("Please select a directory where all apks are stored:")
            temp = input()
            print("Are you sure " + str(walk_dir) + " is your directory?\n Y/N")
            resp = input()
            if resp is "y" or "Y":
                if os.path.isdir(temp):
                    walk_dir = temp
                    return
                else:
                    print("Error, this is not a valid directory")
                    checkWorkingDir('init')
            else:
                checkWorkingDir('init')
        else:
            walk_dir = sys.argv[1]
            print("Work Directory is currently set to: " + walk_dir + "\n")
    else:
        print("Please select a directory where all apks are stored:")
        temp = input()
        print("Are you sure " + temp + " is your directory?\n Y/N")
        resp = input()
        if resp is "y" or "Y":
            if os.path.isdir(temp):
                walk_dir = temp
                mainMenu()
                return
            else:
                print("Error, this is not a valid directory")
                checkWorkingDir()
        else:
            checkWorkingDir()
    
def init():
    global clf
    global needToTrain
    global good_dir
    global bad_dir
    global malwapk
    global goodapk
    global totalapk
    global X,y
    good_dir = None
    bad_dir = None
    malwapk = []
    goodapk = []
    totalapk = []
    y = []
    for dir in os.listdir(walk_dir):
        if "buoni" in dir:
            good_dir = os.path.abspath(os.path.join(walk_dir, dir))
            if os.path.isdir(os.path.join(walk_dir, dir)):
                gpath = os.path.join(walk_dir, dir)
                for gapk in os.listdir(gpath):
                    if os.path.isdir(os.path.join(gpath, gapk)):
                        goodapk.append(gapk)
                        totalapk.append(gapk)
                        y.append(0)
                    elif 'temp.txt' in os.path.join(gpath, gapk):
                        os.remove(os.path.join(gpath, gapk))
        elif "malevoli" in dir:
            bad_dir = os.path.abspath(os.path.join(walk_dir, dir))
            if os.path.isdir(os.path.join(walk_dir, dir)):
                bpath = os.path.join(walk_dir, dir)
                for bapk in os.listdir(bpath):
                    if os.path.isdir(os.path.join(bpath, bapk)):
                        malwapk.append(bapk)
                        totalapk.append(bapk)
                        y.append(1)
                    elif 'temp.txt' in os.path.join(bpath, bapk):
                        os.remove(os.path.join(bpath, bapk))
        elif ".txt" in dir:
            os.remove(os.path.join(walk_dir, dir))
    print("Decompiled apks found in working dir: " + str(totalapk))
    print("Dataset of malicious apks: " + str(malwapk))
    print("Dataset of good apks: " + str(goodapk))

    try:
        with open('classifier.txt', 'r')as openfile:
            lines = openfile.readlines()
            for line in lines:
                if 'y' in line:
                    ytemp = ast.literal_eval(line.split('=')[1])
                if 'apk' in line:
                    apktemp = ast.literal_eval(line.split('=')[1])
                if 'X' in line:
                    Xtemp = ast.literal_eval(line.split('=')[1])
        openfile.close()
    
        if ytemp == y and apktemp == totalapk:
            if firstRun is True:
                print("\nOLD FILE SHOULD BE GOOD, NO NEED TO RETRAIN")
                X = Xtemp
                clf = svm.SVC()
                clf.fit(X, y)
                needToTrain = False
            else:
                needToTrain = False
        else:
            print("\nWARNING!!! OLD CONFIGURATION FILE IS OBSOLETE, DECOMPILE AND TRAIN AGAIN!!!")
            needToTrain = True
    except:
        print("\nOld configuration file does not appear to exist. Decompile first and train the classifier")
            
def cleanWorkingDir():
    print("Cleaning...... This may take some time")
    for dir in os.listdir(walk_dir):
        if "buoni" in dir:
            if os.path.isdir(os.path.join(walk_dir, dir)):
                gpath = os.path.join(walk_dir, dir)
                for gapk in os.listdir(gpath):
                    if os.path.isdir(os.path.join(gpath, gapk)):
                        shutil.rmtree(os.path.join(gpath, gapk))
                  
        else:
            if os.path.isdir(os.path.join(walk_dir, dir)):
                bpath = os.path.join(walk_dir, dir)
                for bapk in os.listdir(bpath):
                    if os.path.isdir(os.path.join(bpath, bapk)):
                        shutil.rmtree(os.path.join(bpath, bapk))
    mainMenu()
    os.remove('classifier.txt')
    os.remove('result.log')
    return

def mainMenu():
    global firstRun
    print("\n\n\n\n############################################\n######## MEGA MALWARE CHECKER SUPER ########\n############################################\n")
    
    checkWorkingDir("init")   
    importRiskyAPI() 
    importRiskyPerms()
    init()
    firstRun = False

    print("\n\n\nChoose an option")
    print("1) Decompile")
    print("2) Train Classifier")
    print("3) Analyse apk")
    print("4) Change Working Directory")
    print("5) Clean Working Directory")
    print("6) Validate classifier results")
    print("7) Exit")

    choiceStr = input()
    choice = int(choiceStr)
    if choice is 1:
        decompile()
    elif choice is 2:
        trainClass()
    elif choice is 3:
        analyseApk()
    elif choice is 4:
        checkWorkingDir('')
    elif choice is 5:
        cleanWorkingDir()
    elif choice is 6:
        validate()
    elif choice is 7:
        exit

if __name__ == "__main__":
    mainMenu()
